# Bible Coding Principles

이 프로젝트에서 모든 코드 작성 시 반드시 준수해야 할 원칙입니다.

---

## 1. SOLID 원칙

### 1.1 단일 책임 원칙 (Single Responsibility Principle)
- 하나의 클래스/모듈/함수는 하나의 책임만 가진다.
- 변경의 이유가 하나뿐이어야 한다.
- 예: `Player` 클래스는 플레이어 상태만 관리하고, 렌더링은 별도 모듈에서 처리한다.

### 1.2 개방-폐쇄 원칙 (Open-Closed Principle)
- 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.
- 새로운 기능 추가 시 기존 코드를 변경하지 않고 확장할 수 있는 구조를 만든다.
- 예: 새로운 적 유형 추가 시 기존 `Enemy` 코드를 수정하지 않고 상속/합성으로 확장한다.

### 1.3 리스코프 치환 원칙 (Liskov Substitution Principle)
- 하위 타입은 상위 타입을 대체할 수 있어야 한다.
- 상속 시 부모의 계약(인터페이스)을 위반하지 않는다.

### 1.4 인터페이스 분리 원칙 (Interface Segregation Principle)
- 사용하지 않는 인터페이스에 의존하지 않는다.
- 큰 인터페이스보다 작고 구체적인 인터페이스 여러 개를 선호한다.

### 1.5 의존성 역전 원칙 (Dependency Inversion Principle)
- 상위 모듈은 하위 모듈에 의존하지 않는다. 둘 다 추상화에 의존한다.
- 구체 구현이 아닌 인터페이스/추상화에 의존한다.
- 예: 게임 로직은 구체적인 렌더러가 아닌 렌더러 인터페이스에 의존한다.

---

## 2. DRY (Don't Repeat Yourself)
- 동일한 로직을 두 곳 이상에 작성하지 않는다.
- 반복되는 코드는 함수, 모듈, 유틸리티로 추출한다.
- 단, 과도한 추상화보다는 명확한 중복 제거에 집중한다.

---

## 3. KISS (Keep It Simple, Stupid)
- 가능한 한 단순한 해결책을 선택한다.
- 복잡한 패턴은 실제로 필요할 때만 도입한다.
- 코드를 읽는 사람이 즉시 이해할 수 있어야 한다.

---

## 4. YAGNI (You Aren't Gonna Need It)
- 현재 필요하지 않은 기능을 미리 구현하지 않는다.
- 미래의 요구사항을 추측하여 설계하지 않는다.
- 실제 요구사항이 발생했을 때 구현한다.

---

## 5. Clean Code

### 5.1 명확한 네이밍
- 변수, 함수, 클래스 이름은 의도를 명확히 드러낸다.
- 약어를 피하고 서술적인 이름을 사용한다.
- 예: `d` 대신 `elapsedDays`, `calc` 대신 `calculateDamage`

### 5.2 짧은 함수
- 함수는 한 가지 일만 수행한다.
- 함수 길이는 20줄 이내를 권장한다.
- 중첩 깊이는 최대 2단계를 권장한다.

### 5.3 주석 최소화
- 코드 자체가 문서가 되도록 작성한다.
- 주석은 "왜(why)"를 설명할 때만 사용한다.
- "무엇(what)"이나 "어떻게(how)"는 코드로 표현한다.

---

## 6. 관심사 분리 (Separation of Concerns)

### 6.1 모듈화
- 기능별로 독립된 모듈로 분리한다.
- 모듈 간 결합도를 최소화하고 응집도를 높인다.

### 6.2 레이어 구분
- 게임 로직, 렌더링, 입력 처리, 데이터 관리를 분리한다.
- 각 레이어는 명확한 인터페이스를 통해 소통한다.
- 권장 레이어 구조:
  - **Core**: 게임 규칙, 상태 관리 (순수 로직, 외부 의존성 없음)
  - **Rendering**: 화면 출력 담당
  - **Input**: 사용자 입력 처리
  - **Data**: 설정, 저장/불러오기

---

## 7. 테스트 가능한 코드

- 순수 함수를 선호한다 (같은 입력에 같은 출력).
- 외부 의존성은 주입받을 수 있도록 설계한다.
- 게임 로직은 렌더링/입력 없이도 테스트 가능해야 한다.
- 테스트 작성 시 AAA 패턴을 따른다: Arrange(준비) - Act(실행) - Assert(검증).

---

## 8. 프로젝트 아키텍처 ("저주받은 밤")

### 8.1 기술 스택
- **엔진**: Godot 4.x (GDScript)
- **해상도**: 320x180 픽셀 퍼펙트 (canvas_items 스트레치 + integer 스케일링)
- **타겟**: 60fps, Steam 배포 (GodotSteam 애드온)
- **버전 관리**: Git

### 8.2 프로젝트 구조
```
res://
├── core/           # 순수 게임 로직 (외부 의존성 없음, 테스트 가능)
├── entities/       # 게임 오브젝트 (씬 + 스크립트)
│   ├── player/
│   ├── enemies/
│   ├── bosses/
│   ├── weapons/
│   └── drops/
├── systems/        # Autoload 매니저 (단일 책임)
├── ui/             # UI 레이어 (HUD, 메뉴, 팝업)
├── data/           # Resource(.tres) 데이터 파일
├── scenes/         # 메인 씬 + 스테이지
└── shared/         # 전역 상수, 열거형, 유틸리티
```

### 8.3 매니저 책임 (systems/)
각 매니저는 반드시 단일 책임만 가진다:

| 매니저 | 책임 |
|--------|------|
| game_manager | FSM 전환, 런 타이머, 시작/종료 생명주기 |
| spawn_manager | WaveData 기반 적/엘리트 시간 스폰, 보스 등장, 화면 밖 적 제거 |
| pool_manager | 적, 투사체, 드롭, 데미지 숫자의 오브젝트 풀 관리 |
| upgrade_manager | 레벨업 선택지 생성, 무기/패시브 적용, 보물 상자 보상, 진화 체크 |
| drop_manager | 적 사망 시 드롭 생성, 마그넷 흡수 로직 |
| stats_manager | 기본 + 패시브 + 영구 업그레이드 합산 최종 스탯 계산 |
| story_manager | 단서 발견 기록, story_flags 갱신, 조건 기반 대사 제공 |
| damage_number_manager | 데미지/회복 숫자 팝업 풀링 및 표시 (최대 20개) |
| audio_manager | BGM 전환, SFX 재생, 볼륨 관리 |

### 8.4 데이터 관리 원칙
- **게임 데이터**: Godot Resource(.tres) 사용 (타입 안전, 에디터 편집 가능)
- **세이브 데이터**: Resource 직렬화 (`user://meta_progress.tres`)
- **밸런스 수치**: 코드에 하드코딩하지 않고 Resource에 분리 (OCP 준수)
- **새 콘텐츠 추가**: 코드 수정 없이 .tres 파일만 추가하는 구조

### 8.5 FSM (게임 상태)
```
enum GameState { MENU, PLAYING, PAUSED, LEVEL_UP, TREASURE, GAME_OVER, VICTORY }
```

### 8.6 성능 규칙 (뱀서라이크 특화)
- **오브젝트 풀링**: Day 1부터 적용 (적, 투사체, 드롭, 데미지 숫자)
- **적 렌더링**: 500마리 이상 시 MultiMeshInstance2D 사용
- **충돌**: 적은 Area2D 기반 (CharacterBody2D보다 가벼움)
- **공간 해싱**: 근접 적 탐색 시 그리드 기반 (O(1) 근사)
- **화면 밖**: VisibleOnScreenNotifier2D로 렌더링 스킵

### 8.7 통신 규칙
- **Signal 기반 느슨한 결합**: 엔티티 간 직접 참조 대신 Signal 사용 (DIP 준수)
- **매니저 접근**: Autoload를 통한 전역 접근, 단 core/ 폴더는 매니저에 의존하지 않음

### 8.8 SOLID vs KISS/YAGNI 균형 가이드
- 확장 가능성이 **높은** 영역 (OCP 우선): 적 종류, 무기 종류, 패시브, 스테이지 → 데이터 기반 확장
- 확장 가능성이 **낮은** 영역 (KISS 우선): FSM 상태, 매니저 구조 → 단순하게 유지
- 적 유형이 10종 미만이면 전략 패턴보다 단순 분기 허용
- 과도한 추상화보다 명확한 코드를 우선

---

## 코드 리뷰 체크리스트

코드 작성 및 리뷰 시 다음을 확인한다:
- [ ] 하나의 함수/클래스가 하나의 책임만 가지는가?
- [ ] 중복 코드가 없는가?
- [ ] 네이밍이 명확한가?
- [ ] 불필요한 복잡성이 없는가?
- [ ] 테스트 가능한 구조인가?
- [ ] 레이어 간 경계가 명확한가?
- [ ] 새 콘텐츠 추가 시 코드 수정 없이 데이터만 추가하면 되는가? (OCP)
- [ ] 오브젝트 풀링이 적용되었는가? (적, 투사체, 드롭)
- [ ] Signal을 통한 느슨한 결합인가? (직접 참조 대신)
- [ ] core/ 폴더의 함수가 순수 함수인가? (외부 의존성 없음)
